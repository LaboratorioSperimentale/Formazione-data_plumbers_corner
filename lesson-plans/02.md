# Introducing the terminal

## Technicalities
>  This part will possibly have a couple slides

1. (who I am and how I ended up here)
2. recap of what is needed today in terms of setup from last time:
    - a working UNIX-like shell (Linux/MacOS/Windows with WSL; if someone is new and doesn't have that, they can follow the tutorial using the online terminal at [bellard.com](https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192))
    - (a text GUI editor, VSCode recommended)

## Introduction
> This part will definitely have slides.

1. what a terminal is/was _historically_, i.e. the physical device and why it was needed
2. what we generally mean by terminal _now_ (an emulator, and in practice a text-based interface to your computer)
3. terminology: terminal/command line/command prompt/shell vs. bash & co. (i.e. specific shells)
4. why, in the era of GUIs, it is still relevant to learn how to use the terminal:
   - many useful programs _only_ have a textual interface <!--example: pandoc, which I used to build my slides-->
   - certain operations are more efficient (or just _more convenient_!) if performed on the command line (cf. modern chat-based AI assistants... free input, but still fully text-based!)
   - using the terminal is often the best way to run your own programs (wrt. the play button in your IDE)
   - basic interaction with remote servers
5. why bash in particular: because it's the #1 UNIX shell (recap on why Unix from previous seminar, recommend [this video](https://www.youtube.com/watch?v=tc4ROCJYbm0) and possibly show some snippets - I should even have Italian subtitles somewhere...)
6. other shells - just briefly mention (__no slides__):
   - a couple other shells that are viable for this course (fish, zsh...)
   - some that might work to some extent (e.g. PowerShell)
   - some that aren't really usable in this session, such as the infamous Windows Command Prompt

## Basic commands
> This part will _not_ have slides; it will be a live demo and they can follow along. I will try to go slowly and Ludovica could help if someone gets stuck on something. I can also make the full shell output available afterwards, maybe

### Moving around the filesystem: 
- `pwd` & concept of _absolute path_
- `cd` & concept of _relative path_
- `ls` (`-l`)
- `tree` (may not be preinstalled, but that's a good excuse for them to learn how to install CLI programs on their distribution $\to$ `sudo`, `apt install` for Ubuntu & co. users)

### Creating, (re)moving, copying files and folders
- `mkdir`
- `touch`
- `cp` (`-r`)
- `rm` (`-r`) 
- `mv`

### Visualizing and editing files
- `cat`
- `more`
- `less`
- `nano` 

### Other useful commands
- `history` (and how to browse it with arrows)
- (`h`)`top`
- (`xdg-`)`open`
- `man`
- `grep` (only simple text, no regex yet)
- `curl` (not because it's that fundamental, but because they need it later if they are using the web shell)
- `htop` (to install, at least for the majority)

## Combining commands
- pipe (example: `cat | grep`, `history | grep`)
- `;`, `&&` and maybe even `||` 
- basic text analysis (all in one line): download a pre-tokenized file, show its contents and find the top 10 most frequent words. This will use `curl` and `cat`, but also introduce other useful commands (`tr`, `sort`, `head`, `uniq`...)
- scripts (rewriting the same thing as a `.sh` file and executing it)
- i/o redirection, getting input from a file (`>` and `<`)

### Exercises
> Here, I will stop talking and let the audiende try to solve some mini-problems. I will ready to answer questions of general interest, and hopefully Ludovica can help with the practical problems each individual encounters

Modify the script in different ways:

- to show the _20_ most frequent words
- to show the 20 _least_ frequent words
- to show all words and their counts _in alphabetical order_
- to write the results to a new text file
- ...

## Spoilers
> Probably one more slide

- save those scripts!
- what is next (how to version control them ;)